import u from"mongoose";var f=new u.Schema({ID:{type:u.SchemaTypes.String,required:!0,unique:!0},data:{type:u.SchemaTypes.Mixed,required:!1},expireAt:{type:u.SchemaTypes.Date,required:!1,default:null}},{timestamps:!0});function c(m,t="JSON"){let e=m.model(t,f);return e.collection.createIndex({expireAt:1},{expireAfterSeconds:0}).catch(()=>null),e}import g from"mongoose";import{TypedEmitter as b}from"tiny-typed-emitter";import w from"lodash";var i=class extends null{constructor(){}static v(t,e,n){return typeof t===e&&!!t?t:n}static pick(t,e){if(!t||typeof t!="object"||!e||typeof e!="string"||!e.includes("."))return t;let n=i.getKeyMetadata(e);return w.get(Object.assign({},t),n.target)}static getKey(t){return t.split(".").shift()}static getKeyMetadata(t){let[e,...n]=t.split(".");return{master:e,child:n,target:n.join(".")}}static shouldExpire(t){return!(typeof t!="number"||t>1/0||t<=0||Number.isNaN(t))}static createDuration(t){return i.shouldExpire(t)?new Date(Date.now()+t):null}};import l from"lodash";var p=class extends b{constructor(t,e={}){super();this.url=t;this.options=e;this.parent=null;this.__child__=!1;this.model=null;Object.defineProperty(this,"__child__",{writable:!0,enumerable:!1,configurable:!0})}isChild(){return!this.isParent()}isParent(){return!this.__child__}get ready(){return!!(this.model&&this.connection)}get readyState(){return this.connection?.readyState??0}async getRaw(t){this.__readyCheck();let e=await this.model.findOne({ID:i.getKey(t)});return!e||e.expireAt&&e.expireAt.getTime()-Date.now()<=0?null:e}async get(t){let e=await this.getRaw(t),n=this.__formatData(e);return i.pick(n,t)}async fetch(t){return await this.get(t)}async set(t,e,n=-1){if(this.__readyCheck(),t.includes(".")){let r=i.getKeyMetadata(t),a=await this.model.findOne({ID:r.master});if(!a)return await this.model.create(i.shouldExpire(n)?{ID:r.master,data:l.set({},r.target,e),expireAt:i.createDuration(n*1e3)}:{ID:r.master,data:l.set({},r.target,e)}),await this.get(t);if(a.data!==null&&typeof a.data!="object")throw new Error("CANNOT_TARGET_NON_OBJECT");let s=Object.assign({},a.data),o=l.set(s,r.target,e);return await a.updateOne({$set:i.shouldExpire(n)?{data:o,expireAt:i.createDuration(n*1e3)}:{data:o}}),await this.get(r.master)}else return await this.model.findOneAndUpdate({ID:t},{$set:i.shouldExpire(n)?{data:e,expireAt:i.createDuration(n*1e3)}:{data:e}},{upsert:!0}),await this.get(t)}async has(t){return await this.get(t)!=null}async delete(t){this.__readyCheck();let e=i.getKeyMetadata(t);if(!e.target)return(await this.model.deleteOne({ID:e.master})).deletedCount>0;let n=await this.model.findOne({ID:e.master});if(!n)return!1;if(n.data!==null&&typeof n.data!="object")throw new Error("CANNOT_TARGET_NON_OBJECT");let r=Object.assign({},n.data);return l.unset(r,e.target),await n.updateOne({$set:{data:r}}),!0}async deleteAll(){return(await this.model.deleteMany()).deletedCount>0}async count(){return await this.model.estimatedDocumentCount()}async ping(){let t=Date.now();return await this.get("SOME_RANDOM_KEY"),Date.now()-t}async instantiateChild(t,e){return await new p(e||this.url,{...this.options,child:!0,parent:this,collectionName:t,shareConnectionFromParent:!!e||!0}).connect()}get table(){return new Proxy(function(){},{construct:(t,e)=>{let n=e[0];if(!n||typeof n!="string")throw new TypeError("ERR_TABLE_NAME");let r=new p(this.url,this.options);return r.connection=this.connection,r.model=c(this.connection,n),r.connect=()=>Promise.resolve(r),Object.defineProperty(r,"table",{get(){},set(){}}),r},apply:()=>{throw new Error("TABLE_IS_NOT_A_FUNCTION")}})}async all(t){this.__readyCheck();let n=(await this.model.find()).filter(r=>!(r.expireAt&&r.expireAt.getTime()-Date.now()<=0)).map(r=>({ID:r.ID,data:this.__formatData(r)})).filter((r,a)=>t?.filter?t.filter(r,a):!0);if(typeof t?.sort=="string"){t.sort.startsWith(".")&&(t.sort=t.sort.slice(1));let r=t.sort.split(".");n=l.sortBy(n,r).reverse()}return typeof t?.limit=="number"&&t.limit>0?n.slice(0,t.limit):n}async drop(){return this.__readyCheck(),await this.model.collection.drop()}async push(t,e){let n=await this.get(t);if(n==null)return Array.isArray(e)?await this.set(t,e):await this.set(t,[e]);if(!Array.isArray(n))throw new Error("TARGET_EXPECTED_ARRAY");return Array.isArray(e)?await this.set(t,n.concat(e)):(n.push(e),await this.set(t,n))}async pull(t,e,n=!0){let r=await this.get(t);if(r==null)return!1;if(!Array.isArray(r))throw new Error("TARGET_EXPECTED_ARRAY");if(Array.isArray(e))return r=r.filter(a=>!e.includes(a)),await this.set(t,r);if(n)return r=r.filter(a=>a!==e),await this.set(t,r);{if(!r.some(o=>o===e))return!1;let s=r.findIndex(o=>o===e);return r=r.splice(s,1),await this.set(t,r)}}async add(t,e){if(typeof e!="number")throw new TypeError("VALUE_MUST_BE_NUMBER");let n=await this.get(t);return await this.set(t,(typeof n=="number"?n:0)+e)}async subtract(t,e){if(typeof e!="number")throw new TypeError("VALUE_MUST_BE_NUMBER");let n=await this.get(t);return await this.set(t,(typeof n=="number"?n:0)-e)}connect(){return new Promise((t,e)=>{if(typeof this.url!="string"||!this.url)return e(new Error("MISSING_MONGODB_URL"));this.__child__=Boolean(this.options.child),this.parent=this.options.parent||null;let n=this.options.collectionName,r=!!this.options.shareConnectionFromParent;if(delete this.options.collectionName,delete this.options.child,delete this.options.parent,delete this.options.shareConnectionFromParent,r&&this.__child__&&this.parent)return this.parent.connection?(this.connection=this.parent.connection,this.model=c(this.connection,i.v(n,"string","JSON")),t(this)):e(new Error("PARENT_HAS_NO_CONNECTION"));g.createConnection(this.url,this.options,(a,s)=>{if(a)return e(a);this.connection=s,this.model=c(this.connection,i.v(n,"string","JSON")),this.emit("ready",this),this.__applyEventsBinding(),t(this)})})}get metadata(){return this.model?{name:this.model.collection.name,db:this.model.collection.dbName,namespace:this.model.collection.namespace}:null}async stats(){return this.__readyCheck(),await this.model.collection.stats()}async close(t=!1){return await this.connection.close(t)}__applyEventsBinding(){this.__readyCheck();let t=["connecting","connected","open","disconnecting","disconnected","close","reconnected","error","fullsetup","all","reconnectFailed","reconnectTries"];for(let e of t)this.connection.prependListener(e,(...n)=>{this.emit(e,...n)})}__formatData(t){return t?.data?t.data:null}__readyCheck(){if(!this.model)throw new Error("DATABASE_NOT_READY")}};export{p as Database,i as Util,f as docSchema};
